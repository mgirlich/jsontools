% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extract.R
\name{json_get_value}
\alias{json_get_value}
\alias{json_get_query}
\title{Extracts a value from JSON}
\usage{
json_get_value(
  x,
  path,
  ptype = NULL,
  default = NULL,
  na = NA,
  bigint_as_char = TRUE
)

json_get_query(x, path, wrap_scalars = FALSE, default = NULL, na = NA)
}
\arguments{
\item{x}{A JSON vector.}

\item{path}{Path to element to extract.}

\item{ptype}{Output type. If \code{NULL}, the default, the output type is
determined by computing the common type across all elements of \code{...}.}

\item{default}{Default value if path doesn't exist or element at path is
empty.}

\item{na}{Default value if element of \code{x} is \code{NA}.}

\item{bigint_as_char}{Convert big integers to character?}

\item{wrap_scalars}{Should scalars be wrapped?}
}
\value{
A vector with class given by \code{.ptype} and length equal to \code{x}.

A \code{json2} vector.
}
\description{
\itemize{
\item extracts a scalar JSON value at the given path.
\item errors if value at path is in object or an array
\item tries to simplify
}
}
\section{SQL 2016 - \code{json_value()}}{

\verb{json_value(<json>, <path> [returning <type>])}

JSON_VALUE is an operator to extract an SQL scalar from a JSON value.
\itemize{
\item it can only extract scalars
\item it errors when the value at the path is an array or an object
}

Arguments
\itemize{
\item RETURNING: specifies the return type <-> ptype
\item ON EMPTY: specifies what to do if the path expression is empty <-> default
\itemize{
\item triggers if
\itemize{
\item value is NULL
\item (lax mode): path does not exist
}
\item NULL: return NULL
\item ERROR: raise exception
\item DEFAULT \<expression\>: evaluate expression
}
\item ON ERROR: Unhandled errors can arise if there is -> no equivalent
\itemize{
\item an input conversion error (for example, if the context item cannot be parsed),
\item an error returned by the SQL/JSON path engine,
\item or an output conversion error.
\item choices as in \verb{ON EMPTY}
}
}
}

\section{SQL 2016 - \code{json_query()}}{

\verb{json_query(<json>, <path>, ...)}

JSON_QUERY is an operator to extract SQL/JSON values from a JSON value.
\itemize{
\item it can extract any JSON type;
\item it always returns a string;
\item it can extract multiple elements from a JSON document.
}

Arguments
\itemize{
\item WRAPPER:
\itemize{
\item WITHOUT ARRAY:
\item WITH CONDITIONAL ARRAY: -> ON EMPTY disallowed
\item WITH UNCONDITIONAL ARRAY: -> ON EMPTY disallowed
}
\item QUOTES
\itemize{
\item KEEP:
\item OMIT
}
\item ON EMPTY:
\itemize{
\item ERROR
\item NULL
\item EMPTY ARRAY
\item EMPTY OBJECT
}
\item ON ERROR: same choices as in ON EMPTY
}
}

\examples{
x1 <- '{"a": 1, "b": 2}'
json_get_value(x1, "$.a")
json_get_value(c(NA_character_, x1), "$.a")
json_get_value(c(NA_character_, x1), "$.a", na = 3)
json_get_value(x1, "$.c", default = "not there")
try(json_get_value(x1, "$.c"))

json_get_query('{"a": {"b": 1}}', "$.a")
}
