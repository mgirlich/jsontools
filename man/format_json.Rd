% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/format_json.R
\name{format_json}
\alias{format_json}
\title{Convert \R{} objects to JSON}
\usage{
format_json(
  x,
  null = c("list", "null"),
  na = c("null", "string"),
  auto_unbox = FALSE,
  dataframe = c("rows", "columns", "values"),
  matrix = c("rowmajor", "columnmajor"),
  Date = c("ISO8601", "epoch"),
  POSIXt = c("string", "ISO8601", "epoch", "mongo"),
  factor = c("string", "integer"),
  complex = c("string", "list"),
  raw = c("base64", "hex", "mongo"),
  digits = 4,
  json_verbatim = TRUE,
  force = FALSE,
  pretty = FALSE,
  rownames = FALSE,
  always_decimal = FALSE,
  ...
)
}
\arguments{
\item{x}{the object to be encoded}

\item{null}{how to encode NULL values within a list: must be one of 'null' or 'list'}

\item{na}{how to print NA values: must be one of 'null' or 'string'. Defaults are class specific}

\item{auto_unbox}{automatically \code{\link{unbox}} all atomic vectors of length 1. It is usually safer to avoid this and instead use the \code{\link{unbox}} function to unbox individual elements.
An exception is that objects of class \code{AsIs} (i.e. wrapped in \code{I()}) are not automatically unboxed. This is a way to mark single values as length-1 arrays.}

\item{dataframe}{how to encode data.frame objects: must be one of 'rows', 'columns' or 'values'}

\item{matrix}{how to encode matrices and higher dimensional arrays: must be one of 'rowmajor' or 'columnmajor'.}

\item{Date}{how to encode Date objects: must be one of 'ISO8601' or 'epoch'}

\item{POSIXt}{how to encode POSIXt (datetime) objects: must be one of 'string', 'ISO8601', 'epoch' or 'mongo'}

\item{factor}{how to encode factor objects: must be one of 'string' or 'integer'}

\item{complex}{how to encode complex numbers: must be one of 'string' or 'list'}

\item{raw}{how to encode raw objects: must be one of 'base64', 'hex' or 'mongo'}

\item{digits}{max number of decimal digits to print for numeric values. Use \code{I()} to specify significant digits. Use \code{NA} for max precision.}

\item{json_verbatim}{Leave json as it is and do not encode it again?}

\item{force}{unclass/skip objects of classes with no defined JSON mapping}

\item{pretty}{adds indentation whitespace to JSON output. Can be TRUE/FALSE or a number specifying the number of spaces to indent. See \code{\link{prettify}}}

\item{rownames}{For data.frames add a field \verb{_row} with the row name?}

\item{always_decimal}{Use real number notation in whole number doubles?}

\item{...}{arguments passed on to class specific \code{print} methods}
}
\description{
These functions are used to convert between JSON data and \R{} objects. The \code{\link[jsonlite:toJSON]{jsonlite::toJSON}} and \code{\link[jsonlite:fromJSON]{jsonlite::fromJSON}} functions use a class based mapping, which follows conventions outlined in this paper: \link{https://arxiv.org/abs/1403.2805} (also available as vignette).
}
\details{
The \code{\link{toJSON}} and \code{\link{fromJSON}} functions are drop-in replacements for the identically named functions
in packages \code{rjson} and \code{RJSONIO}. Our implementation uses an alternative, somewhat more consistent mapping
between \R{} objects and JSON strings.

The \code{\link{serializeJSON}} and \code{\link{unserializeJSON}} functions in this package use an
alternative system to convert between \R{} objects and JSON, which supports more classes but is much more verbose.

A JSON string is always unicode, using \code{UTF-8} by default, hence there is usually no need to escape any characters.
However, the JSON format does support escaping of unicode characters, which are encoded using a backslash followed by
a lower case \code{"u"} and 4 hex characters, for example: \code{"Z\\u00FCrich"}. The \code{fromJSON} function
will parse such escape sequences but it is usually preferable to encode unicode characters in JSON using native
\code{UTF-8} rather than escape sequences.
}
\examples{
# null
x_null <- list(a = NULL, b = 1)
format_json(x_null)
format_json(x_null, null = "null")

# na
x_na <- list(a = NA, b = 1)
format_json(x_na)
format_json(x_na, na = "string")

# auto_unbox
x_autounbox <- list(1, 1:3)
format_json(x_autounbox)
format_json(x_autounbox, auto_unbox = TRUE)

# dataframe conversion
x_df <- iris[1:2, ]
format_json(x_df, pretty = TRUE)
format_json(x_df, dataframe = "columns", pretty = TRUE)
format_json(x_df, dataframe = "values", pretty = TRUE)

# json_verbatim
x_json <- json2('["a","b"]')
format_json(x_json)
format_json(x_json, json_verbatim = FALSE)

# Decimal vs significant digits
x <- 10 + pi
format_json(x)
format_json(x, digits = NA)
format_json(x, digits = 2)
format_json(x, digits = I(2))

# Force decimal representation
format_json(12)
format_json(12, always_decimal = TRUE)
}
\references{
Jeroen Ooms (2014). The \code{jsonlite} Package: A Practical and Consistent Mapping Between JSON Data and \R{} Objects. \emph{arXiv:1403.2805}. \url{https://arxiv.org/abs/1403.2805}
}
