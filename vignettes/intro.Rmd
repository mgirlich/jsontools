---
title: "intro"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(jsontools)
```

## Goals
This package has three goals:
1. easy parsing from JSON and easy conversion to JSON
2. extract a subset of data from JSON without having to parse everything
3. basic modification of JSON

The second and third goals are motivated by how one can work with JSON in a Postgres database.


## Case Study


```{r}
# json_string <- c(tidyjson::worldbank[1:4], NA_character_)
json_string <- tidyjson::worldbank[1:4]
```

First, we create a JSON vector

```{r}
(json <- json2(json_string))
```

and it also prints nicely in a tibble

```{r}
library(dplyr)
# TODO problem printing in Rmd??
data <- tibble(
  i = seq_along(json),
  body = json
)
```

Let's first have a look at what keys are typically in our JSON objects

```{r}
jsonr_keys(json[1:3])
```


```{r}
data_africa_with_closingdate <- data %>% 
  filter(
    jsonr_has_key(body, "closingdate"),
    jsonr_extract_chr(body, ".regionname") == "Africa"
  )
```


```{r}
data %>% 
  mutate(
    region = jsonr_extract_chr(body, ".regionname"),
    body = json_mutate(body, .regionname = tolower(region)),
    region_new = jsonr_extract_chr(body, ".regionname")
  ) %>% 
  select(-body)
```

or creating a new structure

```{r}
json_build_object(
  data$body,
  regionname,
  totalamt,
  first_major_sector = `.majorsector_percent[0].name`,
  country = .countryshortname,
  major_sectors = `[.majorsector_percent[].Name]`
)
```


## JSON vectors

Create JSON vectors

```{r}
x <- c('{"def": 1, "abc": 2}', '{"def": 2}', '[2, 1, 3]')
json2(x)
json2(c(x, NA))

json_sort(x)
```

comparing

```{r}
x <- new_json2('{"a": {"x": 1, "y": 2}}')
x2 <- new_json2('{"a": {
     "y": 2,
     "x": 1
    }
  }'
)

json_equal(x, x2)
```


## Parsing from JSON

There are already a couple of packages to parse JSON (e.g. `rjson` or `jsonlite`). But for me they all had some drawbacks when working with JSON columns from Postgres:

```{r}
x <- tidyjson::worldbank
RJSONIO::fromJSON(x)
rjson::fromJSON(x)
jsonlite::fromJSON(x)

RJSONIO::fromJSON(NA_character_)
rjson::fromJSON(NA_character_)
jsonlite::fromJSON(NA_character_)

RJSONIO::fromJSON(NULL)
rjson::fromJSON(NULL)
jsonlite::fromJSON(NULL)
```


* they are not vectorized. `rjson` simply uses the first element of the input, `RJSONIO` throws an error, and `jsonlite` pastes the input together and then complains about trailing garbage.
* one cannot control what happens with `NA` as input.
* one cannot control what happens with `NULL` as input.
* the automatic conversion of `jsonlite` is great but cannot be controlled very well.
* the camel case syntax doesn't fit to the rest of the tidyverse.

`jsontools` relies on `jsonlite` for parsing from JSON and conversion to JSON. For parsing it has the following functions:

* `parse_json()` to parse a character vector of length 1 (i.e. a scalar).
* `parse_json_vector()` to parse a character vector of any length.

To control what is returned on `NA` resp. `NULL` as input there are the arguments `.na` and `.null`.


## Conversion to JSON

drawbacks:

* not vectorized
* no JSON vector class --> printing is not so nice
* converting a data frame rowwise to a vector of JSON is not so easy or slow.

For conversion there are the following functions:

* `format_json()`: convert an R object to JSON.
* `format_json_vector()`: convert each element of an R object to JSON and return them as a JSON vector.
* `format_json_rowwise()`:


## Index


## Extract JSON data

Three kind of function simplify working with JSON:

* `json_extract()` and variants to extract data from a JSON vector.
* `json_has_key()`, `json_has_path()` and variants to check whether a certain element exists.
* `json_keys()` to get the keys of an object.


## Basic modification of JSON

* `json_mutate()` # mutate
* `json_merge()`: merge with another JSON.
* `json_build_object()` # transmute
* `json_delete_id()`: to delete the element at a given index
