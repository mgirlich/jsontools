---
title: "intro"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(jsontools)
```

## Overview

With the increasing support of JSON in databases and since 2016 even support 
in the SQL standard, JSON data in vectors become more common. With jsontools
one can easily work with JSON vectors in R. 
The three main parts are:
1. parsing from JSON and converting to JSON
2. direct manipulation of JSON without parsing and conversion over R
3. extract data from JSON without parsing everything


## Getting to know the data

We work with a JSON of GitHub commits to dplyr. Printing the first two elements
looks quite messy

```{r}
gh_commits_vec[1:2]
class(gh_commits_vec)
```

because this is still a character vector. So, we first convert it into a JSON
vector

```{r}
gh_commits_vec <- as_json2(gh_commits_vec)
gh_commits_vec
```

<!-- This looks better but is still a bit messy. To get a quick overview we use -->
<!-- `json_glimpse()` -->

<!-- ```{r} -->
<!-- json_glimpse(gh_commits_vec[2]) -->
<!-- ``` -->

## Extract data

TODO: example for using `jsonr_has_key()`

To extract data from the JSON vector we need to know about the JSON path syntax
used here. It comes from the command line tool [jq](https://stedolan.github.io/jq/)
and is very similar to the SQL standard.
The path to the key of an object is simply a dot followed by the key ".key".
And for nested objects one simply concatenates this syntax ".key1.key2". For
example to get the message in the commit one uses the path ".commit.message".

To find out who commited we use `json_get_value()`

```{r}
json_get_value(gh_commits_vec, "$.commit.committer.name")
```

```{r}
json_get_query(gh_commits_vec, "$.commit.committer") %>% 
  json_get_value("$.name")
```


Now, we can easily use dplyr to work with JSON data

```{r}
library(dplyr)

commits_df <- tibble(json = gh_commits_vec)
commits_df <- commits_df %>% 
  dplyr::transmute(
    sha = json_get_value(json, "$.sha"),
    committer_name = json_get_value(gh_commits_vec, "$.commit.committer.name"),
    message = json_get_value(gh_commits_vec, "$.commit.message")
  )
commits_df
```

## Modify JSON

Romain and Hadley actually wanted to use their rstudio email address instead
of the ones they used. With `jsonr_extract_*()` we can extract data, manipulate
it in R and with `json_mutate()` mutate the data in our JSON

```{r}
emails <- json_get_value(gh_commits_vec, "$.commit.committer.email")
emails[emails == "romain@r-enthusiasts.com"] <- "romain.francois@rstudio.com"
emails[emails == "h.wickham@gmail.com"] <- "hadley.wickham@rstudio.com"

gh_commits_vec <- json_mutate(
  gh_commits_vec,
  .commit.committer.email = emails,
  .commit.author.email = emails
)
gh_commits_vec
```


TODO better example with `json_build_object()`

```{r}
gh_commits_vec %>% 
  json_build_object(
    sha = .sha,
    committer_name = .commit.committer.name,
    committer_mail = .commit.committer.email
  )
```


<!-- ## Comparing JSON vectors -->

<!-- Checking if two JSONs are equal can be done with `json_equal()`. In the -->
<!-- comparison -->

<!-- * the formatting is ignored, i.e. it doesn't matter whether one JSON is minified -->
<!-- while the other is not -->
<!-- * and the order of keys doesn't matter. This is useful for example when -->
<!-- comparing a locally constructed JSON with one Postgres because Postgres sorts -->
<!-- the JSON when storing it. -->

<!-- ```{r} -->
<!-- x <- new_json2('{"a": {"x": 1, "y": 2}}') -->
<!-- x2 <- new_json2('{"a": { -->
<!--      "y": 2, -->
<!--      "x": 1 -->
<!--     } -->
<!--   }' -->
<!-- ) -->

<!-- json_equal(x, x2) -->
<!-- ``` -->


## Parsing from JSON

There are already a couple of packages to parse JSON (e.g. `rjson` or `jsonlite`). But for me they all had some drawbacks when working with JSON columns from Postgres:

```{r error=TRUE}
x <- tidyjson::worldbank
RJSONIO::fromJSON(x)
rjson::fromJSON(x)
jsonlite::fromJSON(x)

RJSONIO::fromJSON(NA_character_)
rjson::fromJSON(NA_character_)
jsonlite::fromJSON(NA_character_)

RJSONIO::fromJSON(NULL)
rjson::fromJSON(NULL)
jsonlite::fromJSON(NULL)
```


* they are not vectorized. `rjson` simply uses the first element of the input, `RJSONIO` throws an error, and `jsonlite` pastes the input together and then complains about trailing garbage.
* one cannot control what happens with `NA` as input.
* one cannot control what happens with `NULL` as input.
* the automatic conversion of `jsonlite` is great but cannot be controlled very well.
* the camel case syntax doesn't fit to the rest of the tidyverse.

`jsontools` relies on `jsonlite` for parsing from JSON and conversion to JSON. For parsing it has the following functions:

* `parse_json()` to parse a character vector of length 1 (i.e. a scalar).
* `parse_json_vector()` to parse a character vector of any length.

To control what is returned on `NA` resp. `NULL` as input there are the arguments `.na` and `.null`.


## Converting to JSON

drawbacks:

* not vectorized
* no JSON vector class --> printing is not so nice
* converting a data frame rowwise to a vector of JSON is not so easy or slow.

For conversion there are the following functions:

* `format_json()`: convert an R object to JSON.
* `format_json_vector()`: convert each element of an R object to JSON and return them as a JSON vector.
* `format_json_rowwise()`:

## Sources

* [SQLite JSON1 Extension Manual](https://www.sqlite.org/json1.html)
* [Some JSON 1 Examples](http://blog.benjamin-encz.de/post/sqlite-one-to-many-json1-extension/)
