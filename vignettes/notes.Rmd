---
title: "Untitled"
author: "Maximilian Girlich"
date: "8/12/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

gh_repos_json <- readr::read_file(repurrrsive::gh_repos_json())
gh_first_repo_json <- json_get_query(gh_repos_json, "$[0]")

gh_repos_vec <- json_flatten_query(gh_first_repo_json)[1:3]

discog_json <- readr::read_file(repurrrsive::discog_json())
discog_vec <- unclass(json_flatten_query(discog_json)[c(1, 4)])

got_json <- readr::read_file(repurrrsive::got_chars_json())
got_vec <- unclass(json_flatten_query(got_json)[c(29, 30)])
```

## Basics

* orient on the [SQL 2016 standard for JSON](https://standards.iso.org/ittf/PubliclyAvailableStandards/c067367_ISO_IEC_TR_19075-6_2017.zip)
* short overview on [modern SQL](https://modern-sql.com/blog/2017-06/whats-new-in-sql-2016)
* the `value` suffix is for extracting a scalar value
* the `query` suffix is for extracting JSON objects or arrays

|       SQL       |     jsontools      |               description            |
| --------------- | ------------------ | ------------------------------------ |
| `JSON_VALUE()`  | `json_get_value()` | extract a scalar from JSON           |
| `JSON_QUERY()`  | `json_get_query()` | extract an array or object from JSON |
| `JSON_TABLE()`  |        -           | convert JSON to a rectangle format   |
| `JSON_OBJECT()` |        -           | create an object by explicit values  |
| `JSON_OBJECTAGG()` |        -        | collapse two columns into an object  |
| `JSON_ARRAY()`  |        -           | create an array by explicit values   |
| `JSON_ARRAYAGG()` | `json_agg_array()` | collapse a columns into an array   |
| `IS JSON`       | `json_is_valid()`  | is the expression valid JSON?        |
| `JSON_EXISTS()` | `json_path_exists()` | is the expression valid JSON?      |


Small Helpers
`json_array_length()`: length of JSON array
`json_keys()`
`json_type()`

Working with Arrays and Objects
`json_flatten_query()`
`json_flatten_value()`
`json_each_df()`

`json_unnest_longer()`
`json_unnest_wider()`

`json_build_object)`

Modify JSON
`json_delete()`
`json_merge()`
`json_mutate()`


Read, Write, and Format JSON
`format_json()`
`format_json_list()`
`format_json_rowwise()`

`write_json()`

`parse_json()`
`parse_json_vector()`

Format
`json_minify()`
`json_prettify()`


## Format

`discog_vec` is a character of length 2 that actually contains JSON.

barely readable as normal text
```{r}
discog_vec[1]
```

```{r}
discog_vec <- json2(discog_vec)
```

a bit better as json2
```{r}
discog_vec[1]
```

and nicely readable after prettifying

```{r}
json_prettify(discog_vec[1])
```

## Get Value
now, we can extract values from it with the path language

```{r}
json_get_value(discog_vec, "$.instance_id")
```

also possible for nsted paths

```{r}
json_get_value(discog_vec, "$.basic_information.year")
```

Error if path doesn't exist

```{r error=TRUE}
json_get_value(discog_vec, "$.basic_information.year2")
```

or use default value

```{r}
json_get_value(discog_vec, "$.basic_information.year2", default = 2020)
```

provide a value to use for `NA` elements

```{r}
json_get_value(
  c(
    '{"x": 1}',
    '{"y": 1}',
    NA
  ),
  "$.x",
  na = 5,
  default = 0
)
```


Cannot extract objects and arrays

```{r error=TRUE}
json_get_value(discog_vec, "$.basic_information")
```

## Get Query

Extract objects or arrays

```{r}
labels_vec <- json_get_query(discog_vec, "$.basic_information.labels")
labels_vec
```

```{r}
json_type(labels_vec)
```

it errors when you some of the values are not arrays/objects

```{r}
json_get_query(got_vec, "$.books")
```

use `wrap_scalars = TRUE` to wrap scalar values in an array

```{r}
json_get_query(got_vec, "$.books", wrap_scalars = TRUE)
```

```{r}
json_get_query(
  got_vec,
  "$.books2",
  default = '["the book"]'
)
```


## Flatten

Flatten a JSON array of scalars

```{r}
got_vec %>% 
  json_get_query("$.books", wrap_scalars = TRUE) %>% 
  json_flatten_value()
```

if you have a mix of scalars and arrays -that shouldn't really happen when you
work with the functions in `jsontools`! - the flattening doesn't work

```{r error=TRUE}
mixed <- json2(c(
  a = '["Season 1", "Season 2"]',
  b = '"Season 1"'
))
json_flatten_value(mixed)
```

use `wrap_scalars = TRUE`

```{r}
json_flatten_value(mixed, wrap_scalars = TRUE)
```

and similarly flatten a JSON array of objects or arrays

```{r}
json_flatten_query(labels_vec)
```


### Case Overview

```{r}
# flatten array of objects -> vector of json-objects
json_flatten_query('[{"a":1,"b":2}, {"a":3,"b":4}]')

json_flatten_query(
  c(
    '[{"a":1,"b":2}, {"a":3,"b":4}]',
    '[{"a":11}, {"a":13,"b":14}]'
  )
)

# flatten json-object of objects -> named? vector of json-objects
json_flatten_query('{"a": {"x": 1}, "b": {"y": 2}}')



# flatten array of values
# -> error?
# -> r vector of values?
json_flatten_value("[1, 2, 3]")


# flatten object of values
# -> error?
# -> named r vector of values? --> what about duplicate names? :-/
# json_flatten_value('{"a":1,"b":2}')
# json_flatten_value(c('{"a":1,"b":2}', '{"a":3,"b":4}'))
```

## Unnesting

```{r}
df <- tibble::tibble(json = json2(discog_json))
df

item_df <- df %>%
  json_unnest_longer(
    "json",
    values_to = "item"
  )
item_df

item_df %>%
  json_unnest_longer(
    "item",
    path = c("$.basic_information.artists"),
    values_to = "artist",
    indices_to = "component_id"
  )
```

```{r}
artists <- item_df[1:3, ] %>%
  json_unnest_longer(
    "item",
    path = c("$.basic_information.artists"),
    values_to = "artist",
    indices_to = "component_id"
  )

artists %>% 
  dplyr::mutate(artist = json_delete(artist, "$.id")) %>%
  json_unnest_longer(
    "artist",
    keys_to = "key"
  )

artists %>% 
  json_unnest_wider("artist")
```



### Thoughts

* compare to `purrr::flatten_chr()`
```{r}
library(purrr)

expect_equal(
  flatten_chr(list("a", NULL, c("b", "c"))),
  c("a", "b", "c")
)

expect_equal(
  flatten_chr(list("a", list())),
  c("a")
)

expect_error(
  flatten_chr(list("a", list("a"))),
  c("a")
)
```
  * `list()` <-> array
  * flatten every element of list by one hierarchy then combine
  * elements of list: scalars or vectors <-> scalars or arrays
  * `["a", ["b", "c"]]`
    * -> `["a", "b", "c"]`
    * sqlite: -> `c("a", '["b", "c"]')`, i.e. sqlite doesn't iterate over the elements. other result is quite difficult to achieve in sqlite
```{r}
exec_sqlite_json(
  '["a", ["b", "c"]]',
  "SELECT *
     FROM my_tbl,
          JSON_EACH(my_tbl.data)"
)

exec_sqlite_json(
  c("a", '["b", "c"]'),
  "SELECT *
     FROM my_tbl,
          JSON_EACH(my_tbl.data)"
)

exec_sqlite_json(
  c('["a"]', '["b", "c"]'),
  "SELECT *
     FROM my_tbl,
          JSON_EACH(my_tbl.data)"
)

exec_sqlite_json(
  c('a', '["b", "c"]'),
  "SELECT CASE json_type(json_quote(data))
              WHEN 'array' THEN data
              ELSE json_array(data)
            END AS tmp
   FROM my_tbl"
)$tmp %>% cat()
```
    
  * `["a", "b", "c"]`
    * -> `["a", "b", "c"]`
    * or -> `c("a", "b", "c")`
  * `["a", null]` -> `["a"]`
  * `["a", {}]` -> `["a"]`??

* approach here: `list()` <-> json-vector
  * flatten every of json-vector by one hierarchy then combine
  * `c(["a", "b"], ["x", "y"])` -> `c("a", "b", "x", "y")`
  * `c("a", ["x", "y"])`
    * -> error?
    * -> `c("a", "x", "y")`
  * `c([{obj1}, {obj2}], [{obj3}])` -> `c("{obj1}", "{obj2}", "{obj3}")`


* `json_flatten*()` family
  * returns a vector

* `json_flatten_array()`
  * flattens array of json-objects
  * errors otherwise
* `json_flatten_vec(ptype)`
  * flattens array of values
  * errors if array contains object or array

* `json_each_df()`
  * generates a tibble with `key`, `value`, `json_type`, `index`

* `json_unnest()`
  * wrapper around `json_flatten*()`

## General Thoughts

* `json_extract_*(x, path)`
  * extract path
  * `json_extract`
    * return json
    * no type check?
  * `json_extract_lgl/int/dbl/chr`
    * return corresponding type
    * check type in json

* might make sense to have an `unknown` argument, e.g. in `sw_vehicles` the field `length` should be an integer but is text because of `unknown`

```{r}
json_extract('{"a": true}', "$.a")


repurrrsive::sw_vehicles[c(1, 2, 27)] %>% 
  purrr::map("length")
```


