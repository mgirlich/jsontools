---
title: "intro"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(jsontools)
```

## Overview

With the increasing support of JSON in databases and since 2016 even support 
in the SQL standard, JSON data in vectors become more common. With jsontools
one can easily work with JSON vectors in R. 
The three main parts are:
1. parsing from JSON and converting to JSON
2. direct manipulation of JSON without parsing and conversion over R
3. extract data from JSON without parsing everything


## Getting to know the data

We work with a JSON of GitHub commits to dplyr. Printing the first two elements
looks quite messy

```{r}
gh_commits_vec[1:2]
class(gh_commits_vec)
```

because this is still a character vector. So, we first convert it into a JSON
vector

```{r}
gh_commits_vec <- as_json2(gh_commits_vec)
gh_commits_vec
```

<!-- This looks better but is still a bit messy. To get a quick overview we use -->
<!-- `json_glimpse()` -->

<!-- ```{r} -->
<!-- json_glimpse(gh_commits_vec[2]) -->
<!-- ``` -->

## Extract data

To extract data from the JSON vector we need to know about the JSON path syntax
used here. It comes from the command line tool [jq](https://stedolan.github.io/jq/)
and is very similar to the SQL standard.
The path to the key of an object is simply a dot followed by the key ".key".
And for nested objects one simply concatenates this syntax ".key1.key2". For
example to get the message in the commit one uses the path ".commit.message".

To find out who commited we use `json_extract()`

```{r}
json_extract(gh_commits_vec, "$.commit.committer.name")
```

```{r}
json_extract(gh_commits_vec, "$.commit.committer") %>% 
  json_extract("$.name")
```


Now, we can easily use dplyr to work with JSON data

```{r}
library(dplyr)

commits_df <- tibble(json = gh_commits_vec)
commits_df <- commits_df %>% 
  dplyr::transmute(
    sha = json_extract(json, "$.sha"),
    committer_name = json_extract(gh_commits_vec, "$.commit.committer.name"),
    message = json_extract(gh_commits_vec, "$.commit.message")
  )
commits_df
```

## Modify JSON

Romain and Hadley actually wanted to use their rstudio email address instead
of the ones they used. With `jsonr_extract_*()` we can extract data, manipulate
it in R and with `json_mutate()` mutate the data in our JSON

```{r}
emails <- json_extract(gh_commits_vec, "$.commit.committer.email")
emails[emails == "romain@r-enthusiasts.com"] <- "romain.francois@rstudio.com"
emails[emails == "h.wickham@gmail.com"] <- "hadley.wickham@rstudio.com"

gh_commits_vec <- json_mutate(
  gh_commits_vec,
  .commit.committer.email = emails,
  .commit.author.email = emails
)
gh_commits_vec
```


TODO better example with `json_build_object()`

```{r}
gh_commits_vec %>% 
  json_build_object(
    sha = .sha,
    committer_name = .commit.committer.name,
    committer_mail = .commit.committer.email
  )
```


<!-- ## Comparing JSON vectors -->

<!-- Checking if two JSONs are equal can be done with `json_equal()`. In the -->
<!-- comparison -->

<!-- * the formatting is ignored, i.e. it doesn't matter whether one JSON is minified -->
<!-- while the other is not -->
<!-- * and the order of keys doesn't matter. This is useful for example when -->
<!-- comparing a locally constructed JSON with one Postgres because Postgres sorts -->
<!-- the JSON when storing it. -->

<!-- ```{r} -->
<!-- x <- new_json2('{"a": {"x": 1, "y": 2}}') -->
<!-- x2 <- new_json2('{"a": { -->
<!--      "y": 2, -->
<!--      "x": 1 -->
<!--     } -->
<!--   }' -->
<!-- ) -->

<!-- json_equal(x, x2) -->
<!-- ``` -->


## Sources

* [SQLite JSON1 Extension Manual](https://www.sqlite.org/json1.html)
* [Some JSON 1 Examples](http://blog.benjamin-encz.de/post/sqlite-one-to-many-json1-extension/)
